/* 
 * Dynatrace Environment API
 *
 * Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress. If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .Notes about compatibility:* Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this.* We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = Dynatrace.API.Client.SwaggerDateConverter;

namespace Dynatrace.API.Model
{
    /// <summary>
    /// Configuration of a custom device.
    /// </summary>
    [DataContract]
        public partial class CustomDeviceCreation :  IEquatable<CustomDeviceCreation>, IValidatableObject
    {
        /// <summary>
        /// Defines MessageType
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum MessageTypeEnum
        {
            /// <summary>
            /// Enum CUSTOMDEVICE for value: CUSTOM_DEVICE
            /// </summary>
            [EnumMember(Value = "CUSTOM_DEVICE")]
            CUSTOMDEVICE = 1,
            /// <summary>
            /// Enum DELETEENTITYPERTYPE for value: DELETE_ENTITY_PER_TYPE
            /// </summary>
            [EnumMember(Value = "DELETE_ENTITY_PER_TYPE")]
            DELETEENTITYPERTYPE = 2,
            /// <summary>
            /// Enum FILTERVALUESUGGESTIONS for value: FILTER_VALUE_SUGGESTIONS
            /// </summary>
            [EnumMember(Value = "FILTER_VALUE_SUGGESTIONS")]
            FILTERVALUESUGGESTIONS = 3,
            /// <summary>
            /// Enum MULTI for value: MULTI
            /// </summary>
            [EnumMember(Value = "MULTI")]
            MULTI = 4,
            /// <summary>
            /// Enum MULTITYPE for value: MULTI_TYPE
            /// </summary>
            [EnumMember(Value = "MULTI_TYPE")]
            MULTITYPE = 5,
            /// <summary>
            /// Enum SINGLE for value: SINGLE
            /// </summary>
            [EnumMember(Value = "SINGLE")]
            SINGLE = 6,
            /// <summary>
            /// Enum SINGLETYPE for value: SINGLE_TYPE
            /// </summary>
            [EnumMember(Value = "SINGLE_TYPE")]
            SINGLETYPE = 7        }
        /// <summary>
        /// Gets or Sets MessageType
        /// </summary>
        [DataMember(Name="messageType", EmitDefaultValue=false)]
        public MessageTypeEnum? MessageType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CustomDeviceCreation" /> class.
        /// </summary>
        /// <param name="customDeviceId">The internal ID of the custom device.  If you use the ID of an existing device, the respective parameters will be updated. (required).</param>
        /// <param name="displayName">The name of the custom device to be displayed in the user interface. (required).</param>
        /// <param name="group">User defined group ID of entity. The group ID helps to keep a consistent picture of device-group relations. One of many cases where a proper group is important is service detection: you can define which custom devices should lead to the same service by defining the same group ID for them. If you set a group ID, it will be hashed into the Dynatrace entity ID of the custom device. In that case the custom device can only be part of one custom device group. If you don&#x27;t set the group ID, Dynatrace will create it based on the ID or type of the custom device. Also, the group will not be hashed into the device ID which means the device may switch groups..</param>
        /// <param name="ipAddresses">The list of IP addresses that belong to the custom device. These addresses are used to automatically discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If you send a value (including an empty value), the existing values will be overwritten. If you send &#x60;null&#x60; or omit this field, the existing values will be kept..</param>
        /// <param name="listenPorts">The list of ports the custom devices listens to. These ports are used to discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If ports are specified, you should also add at least one IP address or a DNS name for the custom device. If you send a value, the existing values will be overwritten. If you send &#x60;null&#x60;, or an empty value, or omit this field, the existing values will be kept..</param>
        /// <param name="type">The technology type definition of the custom device. It must be the same technology type of the metric you&#x27;re reporting. If you send a value, the existing value will be overwritten. If you send &#x60;null&#x60;, empty or omit this field, the existing value will be kept..</param>
        /// <param name="faviconUrl">The icon to be displayed for your custom component within Smartscape. Provide the full URL of the icon file..</param>
        /// <param name="configUrl">The URL of a configuration web page for the custom device, such as a login page for a firewall or router..</param>
        /// <param name="properties">The list of key-value pair properties that will be shown beneath the infographics of your custom device..</param>
        /// <param name="dnsNames">The list of DNS names related to the custom device. These names are used to automatically discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If you send a value, the existing values will be overwritten. If you send &#x60;null&#x60; or an empty value; or omit this field, the existing values will be kept..</param>
        /// <param name="messageType">messageType.</param>
        public CustomDeviceCreation(string customDeviceId = default(string), string displayName = default(string), string group = default(string), List<string> ipAddresses = default(List<string>), List<int?> listenPorts = default(List<int?>), string type = default(string), string faviconUrl = default(string), string configUrl = default(string), Dictionary<string, string> properties = default(Dictionary<string, string>), List<string> dnsNames = default(List<string>), MessageTypeEnum? messageType = default(MessageTypeEnum?))
        {
            // to ensure "customDeviceId" is required (not null)
            if (customDeviceId == null)
            {
                throw new InvalidDataException("customDeviceId is a required property for CustomDeviceCreation and cannot be null");
            }
            else
            {
                this.CustomDeviceId = customDeviceId;
            }
            // to ensure "displayName" is required (not null)
            if (displayName == null)
            {
                throw new InvalidDataException("displayName is a required property for CustomDeviceCreation and cannot be null");
            }
            else
            {
                this.DisplayName = displayName;
            }
            this.Group = group;
            this.IpAddresses = ipAddresses;
            this.ListenPorts = listenPorts;
            this.Type = type;
            this.FaviconUrl = faviconUrl;
            this.ConfigUrl = configUrl;
            this.Properties = properties;
            this.DnsNames = dnsNames;
            this.MessageType = messageType;
        }
        
        /// <summary>
        /// The internal ID of the custom device.  If you use the ID of an existing device, the respective parameters will be updated.
        /// </summary>
        /// <value>The internal ID of the custom device.  If you use the ID of an existing device, the respective parameters will be updated.</value>
        [DataMember(Name="customDeviceId", EmitDefaultValue=false)]
        public string CustomDeviceId { get; set; }

        /// <summary>
        /// The name of the custom device to be displayed in the user interface.
        /// </summary>
        /// <value>The name of the custom device to be displayed in the user interface.</value>
        [DataMember(Name="displayName", EmitDefaultValue=false)]
        public string DisplayName { get; set; }

        /// <summary>
        /// User defined group ID of entity. The group ID helps to keep a consistent picture of device-group relations. One of many cases where a proper group is important is service detection: you can define which custom devices should lead to the same service by defining the same group ID for them. If you set a group ID, it will be hashed into the Dynatrace entity ID of the custom device. In that case the custom device can only be part of one custom device group. If you don&#x27;t set the group ID, Dynatrace will create it based on the ID or type of the custom device. Also, the group will not be hashed into the device ID which means the device may switch groups.
        /// </summary>
        /// <value>User defined group ID of entity. The group ID helps to keep a consistent picture of device-group relations. One of many cases where a proper group is important is service detection: you can define which custom devices should lead to the same service by defining the same group ID for them. If you set a group ID, it will be hashed into the Dynatrace entity ID of the custom device. In that case the custom device can only be part of one custom device group. If you don&#x27;t set the group ID, Dynatrace will create it based on the ID or type of the custom device. Also, the group will not be hashed into the device ID which means the device may switch groups.</value>
        [DataMember(Name="group", EmitDefaultValue=false)]
        public string Group { get; set; }

        /// <summary>
        /// The list of IP addresses that belong to the custom device. These addresses are used to automatically discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If you send a value (including an empty value), the existing values will be overwritten. If you send &#x60;null&#x60; or omit this field, the existing values will be kept.
        /// </summary>
        /// <value>The list of IP addresses that belong to the custom device. These addresses are used to automatically discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If you send a value (including an empty value), the existing values will be overwritten. If you send &#x60;null&#x60; or omit this field, the existing values will be kept.</value>
        [DataMember(Name="ipAddresses", EmitDefaultValue=false)]
        public List<string> IpAddresses { get; set; }

        /// <summary>
        /// The list of ports the custom devices listens to. These ports are used to discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If ports are specified, you should also add at least one IP address or a DNS name for the custom device. If you send a value, the existing values will be overwritten. If you send &#x60;null&#x60;, or an empty value, or omit this field, the existing values will be kept.
        /// </summary>
        /// <value>The list of ports the custom devices listens to. These ports are used to discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If ports are specified, you should also add at least one IP address or a DNS name for the custom device. If you send a value, the existing values will be overwritten. If you send &#x60;null&#x60;, or an empty value, or omit this field, the existing values will be kept.</value>
        [DataMember(Name="listenPorts", EmitDefaultValue=false)]
        public List<int?> ListenPorts { get; set; }

        /// <summary>
        /// The technology type definition of the custom device. It must be the same technology type of the metric you&#x27;re reporting. If you send a value, the existing value will be overwritten. If you send &#x60;null&#x60;, empty or omit this field, the existing value will be kept.
        /// </summary>
        /// <value>The technology type definition of the custom device. It must be the same technology type of the metric you&#x27;re reporting. If you send a value, the existing value will be overwritten. If you send &#x60;null&#x60;, empty or omit this field, the existing value will be kept.</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// The icon to be displayed for your custom component within Smartscape. Provide the full URL of the icon file.
        /// </summary>
        /// <value>The icon to be displayed for your custom component within Smartscape. Provide the full URL of the icon file.</value>
        [DataMember(Name="faviconUrl", EmitDefaultValue=false)]
        public string FaviconUrl { get; set; }

        /// <summary>
        /// The URL of a configuration web page for the custom device, such as a login page for a firewall or router.
        /// </summary>
        /// <value>The URL of a configuration web page for the custom device, such as a login page for a firewall or router.</value>
        [DataMember(Name="configUrl", EmitDefaultValue=false)]
        public string ConfigUrl { get; set; }

        /// <summary>
        /// The list of key-value pair properties that will be shown beneath the infographics of your custom device.
        /// </summary>
        /// <value>The list of key-value pair properties that will be shown beneath the infographics of your custom device.</value>
        [DataMember(Name="properties", EmitDefaultValue=false)]
        public Dictionary<string, string> Properties { get; set; }

        /// <summary>
        /// The list of DNS names related to the custom device. These names are used to automatically discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If you send a value, the existing values will be overwritten. If you send &#x60;null&#x60; or an empty value; or omit this field, the existing values will be kept.
        /// </summary>
        /// <value>The list of DNS names related to the custom device. These names are used to automatically discover the horizontal communication relationship between this component and all other observed components within Smartscape. Once a connection is discovered, it is automatically mapped and shown within Smartscape. If you send a value, the existing values will be overwritten. If you send &#x60;null&#x60; or an empty value; or omit this field, the existing values will be kept.</value>
        [DataMember(Name="dnsNames", EmitDefaultValue=false)]
        public List<string> DnsNames { get; set; }


        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CustomDeviceCreation {\n");
            sb.Append("  CustomDeviceId: ").Append(CustomDeviceId).Append("\n");
            sb.Append("  DisplayName: ").Append(DisplayName).Append("\n");
            sb.Append("  Group: ").Append(Group).Append("\n");
            sb.Append("  IpAddresses: ").Append(IpAddresses).Append("\n");
            sb.Append("  ListenPorts: ").Append(ListenPorts).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  FaviconUrl: ").Append(FaviconUrl).Append("\n");
            sb.Append("  ConfigUrl: ").Append(ConfigUrl).Append("\n");
            sb.Append("  Properties: ").Append(Properties).Append("\n");
            sb.Append("  DnsNames: ").Append(DnsNames).Append("\n");
            sb.Append("  MessageType: ").Append(MessageType).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CustomDeviceCreation);
        }

        /// <summary>
        /// Returns true if CustomDeviceCreation instances are equal
        /// </summary>
        /// <param name="input">Instance of CustomDeviceCreation to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CustomDeviceCreation input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.CustomDeviceId == input.CustomDeviceId ||
                    (this.CustomDeviceId != null &&
                    this.CustomDeviceId.Equals(input.CustomDeviceId))
                ) && 
                (
                    this.DisplayName == input.DisplayName ||
                    (this.DisplayName != null &&
                    this.DisplayName.Equals(input.DisplayName))
                ) && 
                (
                    this.Group == input.Group ||
                    (this.Group != null &&
                    this.Group.Equals(input.Group))
                ) && 
                (
                    this.IpAddresses == input.IpAddresses ||
                    this.IpAddresses != null &&
                    input.IpAddresses != null &&
                    this.IpAddresses.SequenceEqual(input.IpAddresses)
                ) && 
                (
                    this.ListenPorts == input.ListenPorts ||
                    this.ListenPorts != null &&
                    input.ListenPorts != null &&
                    this.ListenPorts.SequenceEqual(input.ListenPorts)
                ) && 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.FaviconUrl == input.FaviconUrl ||
                    (this.FaviconUrl != null &&
                    this.FaviconUrl.Equals(input.FaviconUrl))
                ) && 
                (
                    this.ConfigUrl == input.ConfigUrl ||
                    (this.ConfigUrl != null &&
                    this.ConfigUrl.Equals(input.ConfigUrl))
                ) && 
                (
                    this.Properties == input.Properties ||
                    this.Properties != null &&
                    input.Properties != null &&
                    this.Properties.SequenceEqual(input.Properties)
                ) && 
                (
                    this.DnsNames == input.DnsNames ||
                    this.DnsNames != null &&
                    input.DnsNames != null &&
                    this.DnsNames.SequenceEqual(input.DnsNames)
                ) && 
                (
                    this.MessageType == input.MessageType ||
                    (this.MessageType != null &&
                    this.MessageType.Equals(input.MessageType))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.CustomDeviceId != null)
                    hashCode = hashCode * 59 + this.CustomDeviceId.GetHashCode();
                if (this.DisplayName != null)
                    hashCode = hashCode * 59 + this.DisplayName.GetHashCode();
                if (this.Group != null)
                    hashCode = hashCode * 59 + this.Group.GetHashCode();
                if (this.IpAddresses != null)
                    hashCode = hashCode * 59 + this.IpAddresses.GetHashCode();
                if (this.ListenPorts != null)
                    hashCode = hashCode * 59 + this.ListenPorts.GetHashCode();
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.FaviconUrl != null)
                    hashCode = hashCode * 59 + this.FaviconUrl.GetHashCode();
                if (this.ConfigUrl != null)
                    hashCode = hashCode * 59 + this.ConfigUrl.GetHashCode();
                if (this.Properties != null)
                    hashCode = hashCode * 59 + this.Properties.GetHashCode();
                if (this.DnsNames != null)
                    hashCode = hashCode * 59 + this.DnsNames.GetHashCode();
                if (this.MessageType != null)
                    hashCode = hashCode * 59 + this.MessageType.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
