/* 
 * Dynatrace Environment API
 *
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, refer to the [help page](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Dynatrace.API.Client;
using Dynatrace.API.Model;

namespace Dynatrace.API.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface ILogsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>AggregatedLog</returns>
        AggregatedLog GetLogHistogramData (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);

        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>ApiResponse of AggregatedLog</returns>
        ApiResponse<AggregatedLog> GetLogHistogramDataWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);
        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>LogQueryResult</returns>
        LogQueryResult GetLogRecords (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);

        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>ApiResponse of LogQueryResult</returns>
        ApiResponse<LogQueryResult> GetLogRecordsWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);
        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns></returns>
        void StoreLog (LogJsonMessage body = null);

        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> StoreLogWithHttpInfo (LogJsonMessage body = null);
        #endregion Synchronous Operations

        #region Asynchronous Operations
        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>Task of AggregatedLog</returns>
        System.Threading.Tasks.Task<AggregatedLog> GetLogHistogramDataAsync (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);

        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>Task of ApiResponse (AggregatedLog)</returns>
        System.Threading.Tasks.Task<ApiResponse<AggregatedLog>> GetLogHistogramDataAsyncWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);
        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>Task of LogQueryResult</returns>
        System.Threading.Tasks.Task<LogQueryResult> GetLogRecordsAsync (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);

        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>Task of ApiResponse (LogQueryResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<LogQueryResult>> GetLogRecordsAsyncWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);
        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task StoreLogAsync (LogJsonMessage body = null);

        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> StoreLogAsyncWithHttpInfo (LogJsonMessage body = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class LogsApi : ILogsApi
    {
        private Dynatrace.API.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="LogsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LogsApi(String basePath)
        {
            this.Configuration = new Dynatrace.API.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogsApi"/> class
        /// </summary>
        /// <returns></returns>
        public LogsApi()
        {
            this.Configuration = Dynatrace.API.Client.Configuration.Default;

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public LogsApi(Dynatrace.API.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Dynatrace.API.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Dynatrace.API.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Dynatrace.API.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>AggregatedLog</returns>
        public AggregatedLog GetLogHistogramData (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {
             ApiResponse<AggregatedLog> localVarResponse = GetLogHistogramDataWithHttpInfo(from, to, query, timeBuckets, maxGroupValues, groupBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>ApiResponse of AggregatedLog</returns>
        public ApiResponse< AggregatedLog > GetLogHistogramDataWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {

            var localVarPath = "/logs/aggregate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (timeBuckets != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeBuckets", timeBuckets)); // query parameter
            if (maxGroupValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxGroupValues", maxGroupValues)); // query parameter
            if (groupBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "groupBy", groupBy)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogHistogramData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AggregatedLog>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AggregatedLog) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AggregatedLog)));
        }

        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>Task of AggregatedLog</returns>
        public async System.Threading.Tasks.Task<AggregatedLog> GetLogHistogramDataAsync (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {
             ApiResponse<AggregatedLog> localVarResponse = await GetLogHistogramDataAsyncWithHttpInfo(from, to, query, timeBuckets, maxGroupValues, groupBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets log record aggregation in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Expected result is a map of fields with values and their occurrences divided into time buckets. Bucketing is being done at 1ms resolution so it is possible for time range covered by buckets to be wider than timeframe. In that case fewer buckets will be returned than provided in query parameter: timeBuckets.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="timeBuckets">Time buckets used in aggregation (optional, default to 1)</param>
        /// <param name="maxGroupValues">Max distinct values per group in aggregation (optional, default to 10)</param>
        /// <param name="groupBy">Grouping used for aggregation (optional)</param>
        /// <returns>Task of ApiResponse (AggregatedLog)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AggregatedLog>> GetLogHistogramDataAsyncWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {

            var localVarPath = "/logs/aggregate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (timeBuckets != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeBuckets", timeBuckets)); // query parameter
            if (maxGroupValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxGroupValues", maxGroupValues)); // query parameter
            if (groupBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "groupBy", groupBy)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogHistogramData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AggregatedLog>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AggregatedLog) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AggregatedLog)));
        }

        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>LogQueryResult</returns>
        public LogQueryResult GetLogRecords (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {
             ApiResponse<LogQueryResult> localVarResponse = GetLogRecordsWithHttpInfo(from, to, limit, query, sort, nextSliceKey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>ApiResponse of LogQueryResult</returns>
        public ApiResponse< LogQueryResult > GetLogRecordsWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {

            var localVarPath = "/logs/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            if (nextSliceKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextSliceKey", nextSliceKey)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogRecords", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LogQueryResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LogQueryResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LogQueryResult)));
        }

        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>Task of LogQueryResult</returns>
        public async System.Threading.Tasks.Task<LogQueryResult> GetLogRecordsAsync (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {
             ApiResponse<LogQueryResult> localVarResponse = await GetLogRecordsAsyncWithHttpInfo(from, to, limit, query, sort, nextSliceKey);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets log records in the specified timeframe | maturity&#x3D;EARLY_ADOPTER Only the first log records matching specified sorting and filtering are included in the output. The limit of log records is specified by the **limit** query parameter. Log records are sorted by specified sort criteria. In case of query considered too large to be fulfilled in a single call,results are divided into slices which can be fetched using query slice keys provided in the response. When a query slice key is specified, only log records belonging to that particular results slice are provided.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records from all slices.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">Filtering query written in LQL (optional)</param>
        /// <param name="sort">Specifies field that represents sorting for the log records list.  Field has a sign prefix (+/-) which corresponds to the sorting order ( + for ascending and - for descending)  If no sign prefix is set, then default ascending sorting order will be applied  The sorting order of the log records. You can sort records by timestamp in ascending or descending order. Specify +timestamp to show the most recent records first or -timestamp to show the oldest records first. (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">Provides parameters for obtaining log records from a query slice (optional)</param>
        /// <returns>Task of ApiResponse (LogQueryResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LogQueryResult>> GetLogRecordsAsyncWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {

            var localVarPath = "/logs/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            if (nextSliceKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextSliceKey", nextSliceKey)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogRecords", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LogQueryResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LogQueryResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LogQueryResult)));
        }

        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns></returns>
        public void StoreLog (LogJsonMessage body = null)
        {
             StoreLogWithHttpInfo(body);
        }

        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> StoreLogWithHttpInfo (LogJsonMessage body = null)
        {

            var localVarPath = "/logs/ingest";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8", 
                "text/plain; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("StoreLog", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task StoreLogAsync (LogJsonMessage body = null)
        {
             await StoreLogAsyncWithHttpInfo(body);

        }

        /// <summary>
        /// Process and store logs | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored to indexed log storage. This API requires an Environment or Cluster ActiveGate available with Log Analytics Collector module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The log message in JSON or plain text format, depending on request Content-Type specification. In case of plain text format, message represents a single log event. In case of JSON format, message can be a single JSON object representing a single event or an array of JSON objects representing a set of events. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> StoreLogAsyncWithHttpInfo (LogJsonMessage body = null)
        {

            var localVarPath = "/logs/ingest";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8", 
                "text/plain; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("StoreLog", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }


    }
}
