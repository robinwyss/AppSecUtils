/* 
 * Dynatrace Environment API
 *
 * Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress. If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .Notes about compatibility:* Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this.* We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Dynatrace.API.Client;
using Dynatrace.API.Model;

namespace Dynatrace.API.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface ILogsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>AggregatedLog</returns>
        AggregatedLog GetLogHistogramData (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);

        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>ApiResponse of AggregatedLog</returns>
        ApiResponse<AggregatedLog> GetLogHistogramDataWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);
        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>LogRecordsList</returns>
        LogRecordsList GetLogRecords (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);

        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>ApiResponse of LogRecordsList</returns>
        ApiResponse<LogRecordsList> GetLogRecordsWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);
        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>SuccessEnvelope</returns>
        SuccessEnvelope StoreLog (LogMessageJson body = null);

        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>ApiResponse of SuccessEnvelope</returns>
        ApiResponse<SuccessEnvelope> StoreLogWithHttpInfo (LogMessageJson body = null);
       
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>Task of AggregatedLog</returns>
        System.Threading.Tasks.Task<AggregatedLog> GetLogHistogramDataAsync (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);

        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>Task of ApiResponse (AggregatedLog)</returns>
        System.Threading.Tasks.Task<ApiResponse<AggregatedLog>> GetLogHistogramDataAsyncWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null);
        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>Task of LogRecordsList</returns>
        System.Threading.Tasks.Task<LogRecordsList> GetLogRecordsAsync (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);

        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>Task of ApiResponse (LogRecordsList)</returns>
        System.Threading.Tasks.Task<ApiResponse<LogRecordsList>> GetLogRecordsAsyncWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null);
        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>Task of SuccessEnvelope</returns>
        System.Threading.Tasks.Task<SuccessEnvelope> StoreLogAsync (LogMessageJson body = null);

        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>Task of ApiResponse (SuccessEnvelope)</returns>
        System.Threading.Tasks.Task<ApiResponse<SuccessEnvelope>> StoreLogAsyncWithHttpInfo (LogMessageJson body = null);
        
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class LogsApi : ILogsApi
    {
        private Dynatrace.API.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="LogsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public LogsApi(String basePath)
        {
            this.Configuration = new Dynatrace.API.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogsApi"/> class
        /// </summary>
        /// <returns></returns>
        public LogsApi()
        {
            this.Configuration = Dynatrace.API.Client.Configuration.Default;

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public LogsApi(Dynatrace.API.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Dynatrace.API.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Dynatrace.API.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Dynatrace.API.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>AggregatedLog</returns>
        public AggregatedLog GetLogHistogramData (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {
             ApiResponse<AggregatedLog> localVarResponse = GetLogHistogramDataWithHttpInfo(from, to, query, timeBuckets, maxGroupValues, groupBy);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>ApiResponse of AggregatedLog</returns>
        public ApiResponse< AggregatedLog > GetLogHistogramDataWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {

            var localVarPath = "/logs/aggregate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (timeBuckets != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeBuckets", timeBuckets)); // query parameter
            if (maxGroupValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxGroupValues", maxGroupValues)); // query parameter
            if (groupBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "groupBy", groupBy)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogHistogramData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AggregatedLog>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AggregatedLog) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AggregatedLog)));
        }

        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>Task of AggregatedLog</returns>
        public async System.Threading.Tasks.Task<AggregatedLog> GetLogHistogramDataAsync (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {
             ApiResponse<AggregatedLog> localVarResponse = await GetLogHistogramDataAsyncWithHttpInfo(from, to, query, timeBuckets, maxGroupValues, groupBy);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER Returns the aggregated number of occurrences of log values divided into time slots. It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="timeBuckets">The number of time slots in the result. The query timeframe is divided equally into the specified number of slots. The minimum length of a slot is 1 ms. If not set, 1 is used. (optional, default to 1)</param>
        /// <param name="maxGroupValues">The maximum number of values in each group. You can get up to 100 values per group. If not set, 10 is used. (optional, default to 10)</param>
        /// <param name="groupBy">The groupings to be included in the response. You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;. If not set, all possible groups are returned. You can use this option to check for possible grouping values. (optional)</param>
        /// <returns>Task of ApiResponse (AggregatedLog)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AggregatedLog>> GetLogHistogramDataAsyncWithHttpInfo (string from = null, string to = null, string query = null, int? timeBuckets = null, int? maxGroupValues = null, List<string> groupBy = null)
        {

            var localVarPath = "/logs/aggregate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (timeBuckets != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeBuckets", timeBuckets)); // query parameter
            if (maxGroupValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "maxGroupValues", maxGroupValues)); // query parameter
            if (groupBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "groupBy", groupBy)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogHistogramData", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AggregatedLog>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (AggregatedLog) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AggregatedLog)));
        }

        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>LogRecordsList</returns>
        public LogRecordsList GetLogRecords (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {
             ApiResponse<LogRecordsList> localVarResponse = GetLogRecordsWithHttpInfo(from, to, limit, query, sort, nextSliceKey);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>ApiResponse of LogRecordsList</returns>
        public ApiResponse< LogRecordsList > GetLogRecordsWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {

            var localVarPath = "/logs/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            if (nextSliceKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextSliceKey", nextSliceKey)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogRecords", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LogRecordsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LogRecordsList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LogRecordsList)));
        }

        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>Task of LogRecordsList</returns>
        public async System.Threading.Tasks.Task<LogRecordsList> GetLogRecordsAsync (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {
             ApiResponse<LogRecordsList> localVarResponse = await GetLogRecordsAsyncWithHttpInfo(from, to, limit, query, sort, nextSliceKey);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Reads log records | maturity&#x3D;EARLY_ADOPTER Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter. If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on. Results can be distributed unevenly between slices and some slices might be empty.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The start of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe. You can use one of the following formats: * Timestamp in UTC milliseconds. * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional. * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week. You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;. Supported time units for the relative timeframe are:    * &#x60;m&#x60;: minutes    * &#x60;h&#x60;: hours    * &#x60;d&#x60;: days    * &#x60;w&#x60;: weeks    * &#x60;M&#x60;: months    * &#x60;y&#x60;: years If not set, the current timestamp is used. (optional)</param>
        /// <param name="limit">The desired amount of log records. The maximal allowed limit is 1000. If not set, 1000 is used. (optional, default to 1000)</param>
        /// <param name="query">The log search query. The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). The query has a limit of 20 relations (logical operators between simple expressions (&#x60;AND&#x60;, &#x60;OR&#x60;) or comparison operators (&#x60;&#x3D;&#x60;, &#x60;!&#x3D;&#x60;, &#x60;&lt;&#x60;, &#x60;&lt;&#x3D;&#x60;, &#x60;&gt;&#x60;, &#x60;&gt;&#x3D;&#x60;) in simple expressions). (optional)</param>
        /// <param name="sort">Defines the ordering of the log records.Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied. Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first). (optional, default to -timestamp)</param>
        /// <param name="nextSliceKey">The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response. The first slice is always returned if you don&#x27;t specify this parameter. If this parameter is set, all other query parameters are ignored. (optional)</param>
        /// <returns>Task of ApiResponse (LogRecordsList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<LogRecordsList>> GetLogRecordsAsyncWithHttpInfo (string from = null, string to = null, int? limit = null, string query = null, string sort = null, string nextSliceKey = null)
        {

            var localVarPath = "/logs/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (query != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "query", query)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            if (nextSliceKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextSliceKey", nextSliceKey)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLogRecords", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<LogRecordsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (LogRecordsList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(LogRecordsList)));
        }

        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>SuccessEnvelope</returns>
        public SuccessEnvelope StoreLog (LogMessageJson body = null)
        {
             ApiResponse<SuccessEnvelope> localVarResponse = StoreLogWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>ApiResponse of SuccessEnvelope</returns>
        public ApiResponse< SuccessEnvelope > StoreLogWithHttpInfo (LogMessageJson body = null)
        {

            var localVarPath = "/logs/ingest";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8", 
                "text/plain; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("StoreLog", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SuccessEnvelope>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SuccessEnvelope) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SuccessEnvelope)));
        }

        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>Task of SuccessEnvelope</returns>
        public async System.Threading.Tasks.Task<SuccessEnvelope> StoreLogAsync (LogMessageJson body = null)
        {
             ApiResponse<SuccessEnvelope> localVarResponse = await StoreLogAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER Ingested logs are stored in the indexed log storage. This endpoint requires an Environment or Cluster ActiveGate with the **Log Analytics Collector** module enabled.
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The body of the request. Contains one or more log events to be ingested. The endpoint accepts one of the following payload types, defined by the **Accept** header: * &#x60;text/plain&#x60;: supports only one log event. * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)</param>
        /// <returns>Task of ApiResponse (SuccessEnvelope)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SuccessEnvelope>> StoreLogAsyncWithHttpInfo (LogMessageJson body = null)
        {

            var localVarPath = "/logs/ingest";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8", 
                "text/plain; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("StoreLog", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SuccessEnvelope>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (SuccessEnvelope) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SuccessEnvelope)));
        }


    }
}
