/* 
 * Dynatrace Environment API
 *
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, refer to the [help page](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Dynatrace.API.Client;
using Dynatrace.API.Model;

namespace Dynatrace.API.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IProblemsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>ProblemCloseResult</returns>
        ProblemCloseResult CloseProblem (string problemId, ClosingComment body = null);

        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>ApiResponse of ProblemCloseResult</returns>
        ApiResponse<ProblemCloseResult> CloseProblemWithHttpInfo (string problemId, ClosingComment body = null);
        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns></returns>
        void CreateComment (string problemId, CommentRequestDtoImpl body = null);

        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CreateCommentWithHttpInfo (string problemId, CommentRequestDtoImpl body = null);
        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns></returns>
        void DeleteComment (string problemId, string commentId);

        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCommentWithHttpInfo (string problemId, string commentId);
        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Comment</returns>
        Comment GetComment (string problemId, string commentId);

        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>ApiResponse of Comment</returns>
        ApiResponse<Comment> GetCommentWithHttpInfo (string problemId, string commentId);
        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>CommentsList</returns>
        CommentsList GetComments (string problemId, string nextPageKey = null, long? pageSize = null);

        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>ApiResponse of CommentsList</returns>
        ApiResponse<CommentsList> GetCommentsWithHttpInfo (string problemId, string nextPageKey = null, long? pageSize = null);
        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>Problem</returns>
        Problem GetProblem (string problemId, string fields = null);

        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>ApiResponse of Problem</returns>
        ApiResponse<Problem> GetProblemWithHttpInfo (string problemId, string fields = null);
        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>Problems</returns>
        Problems GetProblems (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null);

        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>ApiResponse of Problems</returns>
        ApiResponse<Problems> GetProblemsWithHttpInfo (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null);
        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns></returns>
        void UpdateComment (string problemId, string commentId, CommentRequestDtoImpl body = null);

        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateCommentWithHttpInfo (string problemId, string commentId, CommentRequestDtoImpl body = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>Task of ProblemCloseResult</returns>
        System.Threading.Tasks.Task<ProblemCloseResult> CloseProblemAsync (string problemId, ClosingComment body = null);

        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>Task of ApiResponse (ProblemCloseResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<ProblemCloseResult>> CloseProblemAsyncWithHttpInfo (string problemId, ClosingComment body = null);
        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CreateCommentAsync (string problemId, CommentRequestDtoImpl body = null);

        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CreateCommentAsyncWithHttpInfo (string problemId, CommentRequestDtoImpl body = null);
        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteCommentAsync (string problemId, string commentId);

        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteCommentAsyncWithHttpInfo (string problemId, string commentId);
        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of Comment</returns>
        System.Threading.Tasks.Task<Comment> GetCommentAsync (string problemId, string commentId);

        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of ApiResponse (Comment)</returns>
        System.Threading.Tasks.Task<ApiResponse<Comment>> GetCommentAsyncWithHttpInfo (string problemId, string commentId);
        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>Task of CommentsList</returns>
        System.Threading.Tasks.Task<CommentsList> GetCommentsAsync (string problemId, string nextPageKey = null, long? pageSize = null);

        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>Task of ApiResponse (CommentsList)</returns>
        System.Threading.Tasks.Task<ApiResponse<CommentsList>> GetCommentsAsyncWithHttpInfo (string problemId, string nextPageKey = null, long? pageSize = null);
        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>Task of Problem</returns>
        System.Threading.Tasks.Task<Problem> GetProblemAsync (string problemId, string fields = null);

        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>Task of ApiResponse (Problem)</returns>
        System.Threading.Tasks.Task<ApiResponse<Problem>> GetProblemAsyncWithHttpInfo (string problemId, string fields = null);
        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>Task of Problems</returns>
        System.Threading.Tasks.Task<Problems> GetProblemsAsync (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null);

        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>Task of ApiResponse (Problems)</returns>
        System.Threading.Tasks.Task<ApiResponse<Problems>> GetProblemsAsyncWithHttpInfo (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null);
        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateCommentAsync (string problemId, string commentId, CommentRequestDtoImpl body = null);

        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateCommentAsyncWithHttpInfo (string problemId, string commentId, CommentRequestDtoImpl body = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class ProblemsApi : IProblemsApi
    {
        private Dynatrace.API.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProblemsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProblemsApi(String basePath)
        {
            this.Configuration = new Dynatrace.API.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProblemsApi"/> class
        /// </summary>
        /// <returns></returns>
        public ProblemsApi()
        {
            this.Configuration = Dynatrace.API.Client.Configuration.Default;

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProblemsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ProblemsApi(Dynatrace.API.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Dynatrace.API.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Dynatrace.API.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Dynatrace.API.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Dynatrace.API.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>ProblemCloseResult</returns>
        public ProblemCloseResult CloseProblem (string problemId, ClosingComment body = null)
        {
             ApiResponse<ProblemCloseResult> localVarResponse = CloseProblemWithHttpInfo(problemId, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>ApiResponse of ProblemCloseResult</returns>
        public ApiResponse< ProblemCloseResult > CloseProblemWithHttpInfo (string problemId, ClosingComment body = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->CloseProblem");

            var localVarPath = "/problems/{problemId}/close";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CloseProblem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ProblemCloseResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ProblemCloseResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ProblemCloseResult)));
        }

        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>Task of ProblemCloseResult</returns>
        public async System.Threading.Tasks.Task<ProblemCloseResult> CloseProblemAsync (string problemId, ClosingComment body = null)
        {
             ApiResponse<ProblemCloseResult> localVarResponse = await CloseProblemAsyncWithHttpInfo(problemId, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Closes the specified problem and adds a closing comment on it | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the closing comment on the problem. (optional)</param>
        /// <returns>Task of ApiResponse (ProblemCloseResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ProblemCloseResult>> CloseProblemAsyncWithHttpInfo (string problemId, ClosingComment body = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->CloseProblem");

            var localVarPath = "/problems/{problemId}/close";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CloseProblem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ProblemCloseResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (ProblemCloseResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ProblemCloseResult)));
        }

        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns></returns>
        public void CreateComment (string problemId, CommentRequestDtoImpl body = null)
        {
             CreateCommentWithHttpInfo(problemId, body);
        }

        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> CreateCommentWithHttpInfo (string problemId, CommentRequestDtoImpl body = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->CreateComment");

            var localVarPath = "/problems/{problemId}/comments";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CreateCommentAsync (string problemId, CommentRequestDtoImpl body = null)
        {
             await CreateCommentAsyncWithHttpInfo(problemId, body);

        }

        /// <summary>
        /// Adds a new comment on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="body">The JSON body of the request. Contains the comment to be added. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> CreateCommentAsyncWithHttpInfo (string problemId, CommentRequestDtoImpl body = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->CreateComment");

            var localVarPath = "/problems/{problemId}/comments";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns></returns>
        public void DeleteComment (string problemId, string commentId)
        {
             DeleteCommentWithHttpInfo(problemId, commentId);
        }

        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCommentWithHttpInfo (string problemId, string commentId)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->DeleteComment");
            // verify the required parameter 'commentId' is set
            if (commentId == null)
                throw new ApiException(400, "Missing required parameter 'commentId' when calling ProblemsApi->DeleteComment");

            var localVarPath = "/problems/{problemId}/comments/{commentId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (commentId != null) localVarPathParams.Add("commentId", this.Configuration.ApiClient.ParameterToString(commentId)); // path parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteCommentAsync (string problemId, string commentId)
        {
             await DeleteCommentAsyncWithHttpInfo(problemId, commentId);

        }

        /// <summary>
        /// Deletes the specified comment from a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteCommentAsyncWithHttpInfo (string problemId, string commentId)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->DeleteComment");
            // verify the required parameter 'commentId' is set
            if (commentId == null)
                throw new ApiException(400, "Missing required parameter 'commentId' when calling ProblemsApi->DeleteComment");

            var localVarPath = "/problems/{problemId}/comments/{commentId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (commentId != null) localVarPathParams.Add("commentId", this.Configuration.ApiClient.ParameterToString(commentId)); // path parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Comment</returns>
        public Comment GetComment (string problemId, string commentId)
        {
             ApiResponse<Comment> localVarResponse = GetCommentWithHttpInfo(problemId, commentId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>ApiResponse of Comment</returns>
        public ApiResponse< Comment > GetCommentWithHttpInfo (string problemId, string commentId)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->GetComment");
            // verify the required parameter 'commentId' is set
            if (commentId == null)
                throw new ApiException(400, "Missing required parameter 'commentId' when calling ProblemsApi->GetComment");

            var localVarPath = "/problems/{problemId}/comments/{commentId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (commentId != null) localVarPathParams.Add("commentId", this.Configuration.ApiClient.ParameterToString(commentId)); // path parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Comment>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Comment) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Comment)));
        }

        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of Comment</returns>
        public async System.Threading.Tasks.Task<Comment> GetCommentAsync (string problemId, string commentId)
        {
             ApiResponse<Comment> localVarResponse = await GetCommentAsyncWithHttpInfo(problemId, commentId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <returns>Task of ApiResponse (Comment)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Comment>> GetCommentAsyncWithHttpInfo (string problemId, string commentId)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->GetComment");
            // verify the required parameter 'commentId' is set
            if (commentId == null)
                throw new ApiException(400, "Missing required parameter 'commentId' when calling ProblemsApi->GetComment");

            var localVarPath = "/problems/{problemId}/comments/{commentId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (commentId != null) localVarPathParams.Add("commentId", this.Configuration.ApiClient.ParameterToString(commentId)); // path parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Comment>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Comment) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Comment)));
        }

        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>CommentsList</returns>
        public CommentsList GetComments (string problemId, string nextPageKey = null, long? pageSize = null)
        {
             ApiResponse<CommentsList> localVarResponse = GetCommentsWithHttpInfo(problemId, nextPageKey, pageSize);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>ApiResponse of CommentsList</returns>
        public ApiResponse< CommentsList > GetCommentsWithHttpInfo (string problemId, string nextPageKey = null, long? pageSize = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->GetComments");

            var localVarPath = "/problems/{problemId}/comments";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (nextPageKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextPageKey", nextPageKey)); // query parameter
            if (pageSize != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageSize", pageSize)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetComments", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CommentsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (CommentsList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CommentsList)));
        }

        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>Task of CommentsList</returns>
        public async System.Threading.Tasks.Task<CommentsList> GetCommentsAsync (string problemId, string nextPageKey = null, long? pageSize = null)
        {
             ApiResponse<CommentsList> localVarResponse = await GetCommentsAsyncWithHttpInfo(problemId, nextPageKey, pageSize);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets all comments on the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)</param>
        /// <returns>Task of ApiResponse (CommentsList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CommentsList>> GetCommentsAsyncWithHttpInfo (string problemId, string nextPageKey = null, long? pageSize = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->GetComments");

            var localVarPath = "/problems/{problemId}/comments";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (nextPageKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextPageKey", nextPageKey)); // query parameter
            if (pageSize != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageSize", pageSize)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetComments", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CommentsList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (CommentsList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CommentsList)));
        }

        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>Problem</returns>
        public Problem GetProblem (string problemId, string fields = null)
        {
             ApiResponse<Problem> localVarResponse = GetProblemWithHttpInfo(problemId, fields);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>ApiResponse of Problem</returns>
        public ApiResponse< Problem > GetProblemWithHttpInfo (string problemId, string fields = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->GetProblem");

            var localVarPath = "/problems/{problemId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fields", fields)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProblem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Problem>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Problem) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Problem)));
        }

        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>Task of Problem</returns>
        public async System.Threading.Tasks.Task<Problem> GetProblemAsync (string problemId, string fields = null)
        {
             ApiResponse<Problem> localVarResponse = await GetProblemAsyncWithHttpInfo(problemId, fields);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Gets the properties of the specified problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)</param>
        /// <returns>Task of ApiResponse (Problem)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Problem>> GetProblemAsyncWithHttpInfo (string problemId, string fields = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->GetProblem");

            var localVarPath = "/problems/{problemId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fields", fields)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProblem", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Problem>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Problem) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Problem)));
        }

        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>Problems</returns>
        public Problems GetProblems (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null)
        {
             ApiResponse<Problems> localVarResponse = GetProblemsWithHttpInfo(fields, nextPageKey, pageSize, from, to, problemSelector, entitySelector, sort);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>ApiResponse of Problems</returns>
        public ApiResponse< Problems > GetProblemsWithHttpInfo (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null)
        {

            var localVarPath = "/problems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fields", fields)); // query parameter
            if (nextPageKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextPageKey", nextPageKey)); // query parameter
            if (pageSize != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageSize", pageSize)); // query parameter
            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (problemSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "problemSelector", problemSelector)); // query parameter
            if (entitySelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "entitySelector", entitySelector)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProblems", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Problems>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Problems) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Problems)));
        }

        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>Task of Problems</returns>
        public async System.Threading.Tasks.Task<Problems> GetProblemsAsync (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null)
        {
             ApiResponse<Problems> localVarResponse = await GetProblemsAsyncWithHttpInfo(fields, nextPageKey, pageSize, from, to, problemSelector, entitySelector, sort);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Lists problems observed within the specified timeframe | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="fields">A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#x27;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#x27;re requesting. (optional)</param>
        /// <param name="nextPageKey">The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#x27;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)</param>
        /// <param name="pageSize">The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)</param>
        /// <param name="from">The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)</param>
        /// <param name="to">The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)</param>
        /// <param name="problemSelector">Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name: &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;).   To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)</param>
        /// <param name="entitySelector">The entity scope of the query.You need to set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;).   And you can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name: &#x60;entityName(\&quot;value\&quot;)&#x60;. By default this filters for entities, whose name **contains** the given value and is **not** case sensitive.   You can modify the behaviour with postfixes: (all of them still not case-sensitive)  * &#x60;entityName.equals&#x60; uses exact matches instead of the contains logic  * &#x60;entityName.startsWith&#x60; filters for names that start with the given value  * &#x60;entityName.in&#x60; behaves exactly the same as &#x60;entityName.equals&#x60;, but allows more than one value – one of which has to match  * surrounding any of the aforementioned entity name predicates with &#x60;caseSensitive&#x60; will make them case sensitive. (For example &#x60;caseSensitive(entityName.equals(caseSensitiveName))&#x60;) * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.lte(now-3h)&#x60;. You can use any of the values also available in the from/to parameters.  The following modifiers for this predicate exist:  * &#x60;lte&#x60;: Less than or equal  * &#x60;lt&#x60;: Less than  * &#x60;gte&#x60;: Greater than or equal  * &#x60;gt&#x60;: Greater than * Entity property: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. String-based attributes are **not** case sensitive, but can be used in combination with &#x60;caseSensitive&#x60; to change that. * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60;, &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The value can be any valid entity selector.  For example: &#x60;type(HOST),fromRelationships.isInstanceOf(type(HOST_GROUP), entityName.startsWith(host group name))&#x60;  * Case sensitivity: &#x60;caseSensitive(&lt;any entity name or string-based attribute predicate&gt;)&#x60; (see entity name above) * Negation: &#x60;not(&lt;any predicate except type&gt;)&#x60; negates the given predicate.  For more information, see the [Entity selector](https://dt-url.net/apientityselector) help page.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   The length of the string is limited to 10,000 characters.   The scope is limited to 10000 entities !   (optional)</param>
        /// <param name="sort">Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)</param>
        /// <returns>Task of ApiResponse (Problems)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Problems>> GetProblemsAsyncWithHttpInfo (string fields = null, string nextPageKey = null, long? pageSize = null, string from = null, string to = null, string problemSelector = null, string entitySelector = null, string sort = null)
        {

            var localVarPath = "/problems";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (fields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fields", fields)); // query parameter
            if (nextPageKey != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nextPageKey", nextPageKey)); // query parameter
            if (pageSize != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageSize", pageSize)); // query parameter
            if (from != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "from", from)); // query parameter
            if (to != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "to", to)); // query parameter
            if (problemSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "problemSelector", problemSelector)); // query parameter
            if (entitySelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "entitySelector", entitySelector)); // query parameter
            if (sort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sort", sort)); // query parameter
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetProblems", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Problems>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (Problems) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Problems)));
        }

        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns></returns>
        public void UpdateComment (string problemId, string commentId, CommentRequestDtoImpl body = null)
        {
             UpdateCommentWithHttpInfo(problemId, commentId, body);
        }

        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateCommentWithHttpInfo (string problemId, string commentId, CommentRequestDtoImpl body = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->UpdateComment");
            // verify the required parameter 'commentId' is set
            if (commentId == null)
                throw new ApiException(400, "Missing required parameter 'commentId' when calling ProblemsApi->UpdateComment");

            var localVarPath = "/problems/{problemId}/comments/{commentId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (commentId != null) localVarPathParams.Add("commentId", this.Configuration.ApiClient.ParameterToString(commentId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateCommentAsync (string problemId, string commentId, CommentRequestDtoImpl body = null)
        {
             await UpdateCommentAsyncWithHttpInfo(problemId, commentId, body);

        }

        /// <summary>
        /// Updates the specified comment on a problem | maturity&#x3D;EARLY_ADOPTER 
        /// </summary>
        /// <exception cref="Dynatrace.API.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="problemId">The ID of the required problem.</param>
        /// <param name="commentId">The ID of the required comment.</param>
        /// <param name="body">The JSON body of the request. Contains the updated comment. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateCommentAsyncWithHttpInfo (string problemId, string commentId, CommentRequestDtoImpl body = null)
        {
            // verify the required parameter 'problemId' is set
            if (problemId == null)
                throw new ApiException(400, "Missing required parameter 'problemId' when calling ProblemsApi->UpdateComment");
            // verify the required parameter 'commentId' is set
            if (commentId == null)
                throw new ApiException(400, "Missing required parameter 'commentId' when calling ProblemsApi->UpdateComment");

            var localVarPath = "/problems/{problemId}/comments/{commentId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json; charset=utf-8"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (problemId != null) localVarPathParams.Add("problemId", this.Configuration.ApiClient.ParameterToString(problemId)); // path parameter
            if (commentId != null) localVarPathParams.Add("commentId", this.Configuration.ApiClient.ParameterToString(commentId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }
            // authentication (Api-Token) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateComment", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

    }
}
